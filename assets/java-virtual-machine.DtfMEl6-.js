import{_ as p}from"./ValaxyMain.vue_vue_type_style_index_0_lang.CwGK2QKz.js";import"./chunks/@vueuse/motion.BsBBmBGk.js";import{d as f,a as b,u as v}from"./chunks/vue-router.DbYl_Vni.js";import{X as g,b_ as l,bB as C,b3 as M,be as t,_ as a,a5 as n,b5 as J}from"./framework.BXq2oTmp.js";import"./app.DaEmrGxP.js";import"./chunks/dayjs.C6BNYsUE.js";import"./chunks/vue-i18n.lfRrKsMF.js";import"./chunks/pinia.C_YCGfgp.js";import"./chunks/nprogress.DdFZ7jLs.js";import"./YunComment.vue_vue_type_style_index_0_lang.BQ4Fe32A.js";import"./index.dXt3ZyM3.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.DDanGzXB.js";import"./post.BW-oy4du.js";const j=f("/jobs/question/java-virtual-machine",async r=>JSON.parse('{"title":"Java Virtual Machine","description":"","frontmatter":{"title":"Java Virtual Machine","title_zh":"Java 虚拟机","date":"2025-04-11 15:27:14"},"headers":[],"relativePath":"pages/jobs/question/java-virtual-machine.md","lastUpdated":null}'),{lazy:(r,s)=>r.name===s.name}),N={__name:"java-virtual-machine",setup(r,{expose:s}){var u;const{data:i}=j(),d=v(),c=b(),o=Object.assign(c.meta.frontmatter||{},((u=i.value)==null?void 0:u.frontmatter)||{});return d.currentRoute.value.data=i.value,J("valaxy:frontmatter",o),globalThis.$frontmatter=o,s({frontmatter:{title:"Java Virtual Machine",title_zh:"Java 虚拟机",date:"2025-04-11 15:27:14"}}),(e,m)=>{const h=p;return M(),g(h,{frontmatter:C(o)},{"main-content-md":l(()=>m[0]||(m[0]=[a("details",{class:"details custom-block"},[a("summary",null,"JVM 的组成部分有那些？"),a("ul",null,[a("li",null,"类加载器（ClassLoader）：负责将字节码文件加载到运行时数据区。只负责加载字节码文件，不负责验证字节码文件。"),a("li",null,"运行时数据区（Runtime Data Area）：包括方法区、堆、栈、本地方法栈、程序计数器等。"),a("li",null,"执行引擎（Execution Engine）：负责执行字节码文件。将字节码文件解释为机器码执行。"),a("li",null,"本地方法接口（Native Interface）：调用本地接口。")])],-1),a("h2",{id:"内存结构",tabindex:"-1"},[n("内存结构 "),a("a",{class:"header-anchor",href:"#内存结构","aria-label":'Permalink to "内存结构"'},"​")],-1),a("p",null,"JVM 内存结构分为两大部分：方法区和堆，方法区又分为类加载器、运行时常量池、方法区和本地方法栈。",-1),a("ul",null,[a("li",null,"方法区（Method Area）：存储类的结构信息、常量、静态变量等。"),a("li",null,"堆（Heap）：存放对象实例，是垃圾回收的主要区域。"),a("li",null,"本地方法栈（Native Method Stack）：为 JVM 使用到的 native 方法（如调用 C/C++）服务。"),a("li",null,"虚拟机栈（Java Virtual Machine Stack）：每个线程都有一个，存放局部变量、操作数栈、动态链接和方法出口等信息。"),a("li",null,"程序计数器（Program Counter Register）：每条线程都有一个，记录当前线程正在执行的字节码指令地址。"),a("li",null,"运行时常量池（Runtime Constant Pool）：存放编译期生成的各种字面量和符号引用。")],-1),a("h2",{id:"内存模型-jmm",tabindex:"-1"},[n("内存模型 (JMM) "),a("a",{class:"header-anchor",href:"#内存模型-jmm","aria-label":'Permalink to "内存模型 (JMM)"'},"​")],-1),a("p",null,[n("详见 helltractor blog 中"),a("a",{href:"https://blog.helltractor.top/posts/java/java-memory-model/",target:"_blank",rel:"noreferrer"},"Java Memory Model")],-1),a("h2",{id:"垃圾回收-gc",tabindex:"-1"},[n("垃圾回收 (GC) "),a("a",{class:"header-anchor",href:"#垃圾回收-gc","aria-label":'Permalink to "垃圾回收 (GC)"'},"​")],-1),a("p",null,[n("详见 helltractor blog 中"),a("a",{href:"https://blog.helltractor.top/posts/java/garbage-collect/",target:"_blank",rel:"noreferrer"},"Garbage Collect")],-1),a("details",{class:"details custom-block"},[a("summary",null,"Java 垃圾回收的原理机制？"),a("p",null,"JVM 使用可达性分析算法来判断一个对象是否存活。它从一组称为 GC Roots 的对象出发，沿着引用链向下搜索，如果一个对象无法通过任何 GC Root 访问到，就被认为是不可达，即“垃圾”。"),a("p",null,"常见的 GC Roots 包括："),a("ul",null,[a("li",null,"虚拟机栈中的引用对象（局部变量表）；"),a("li",null,"方法区中类的静态属性；"),a("li",null,"方法区中常量引用；"),a("li",null,"本地方法栈中的 JNI 引用；")]),a("p",null,"除了强引用（Strong Reference）外，Java 还提供了三种“引用类型”来配合垃圾回收机制："),a("ul",null,[a("li",null,"软引用：内存不足时会被回收，适合缓存；"),a("li",null,"弱引用：下一次 GC 一定会被回收；"),a("li",null,"虚引用：不会影响生命周期，用于对象被回收时收到通知（配合 ReferenceQueue）；")])],-1),a("details",{class:"details custom-block"},[a("summary",null,"Java 中的垃圾回收器？"),a("ul",null,[a("li",null,"Serial GC：单线程的垃圾回收器，适用于单核 CPU 或堆内存较小的场景。它的优点是简单、高效，但因为只有一个线程执行回收，停顿时间较长，可能影响响应时间；"),a("li",null,"Parallel GC：多线程的垃圾回收器，专门设计用于多核 CPU 环境。它的目标是通过并行处理来提高吞吐量，适用于对吞吐量要求较高的场景，如批处理系统。缺点是可能会产生较长的停顿时间；"),a("li",null,"CMS（Concurrent Mark-Sweep）GC：旨在最小化停顿时间，采用并发标记和清理阶段，通过“停止世界”阶段最小化影响，适合高并发应用，如 Web 服务。但其缺点是容易导致内存碎片，且回收过程中可能出现长时间的“停止世界”现象；"),a("li",null,"G1 GC：作为默认垃圾回收器，G1 结合了 CMS 和 Parallel GC 的优点，支持混合回收（Mix GC），通过将堆划分为多个小的 Region，进行增量式回收，能更灵活地控制停顿时间。G1 特别适用于大内存应用，解决了 CMS 的内存碎片问题，并且可以在较低的停顿时间内提供较高的吞吐量。")])],-1),a("h2",{id:"类加载机制",tabindex:"-1"},[n("类加载机制 "),a("a",{class:"header-anchor",href:"#类加载机制","aria-label":'Permalink to "类加载机制"'},"​")],-1),a("details",{class:"details custom-block"},[a("summary",null,"自定义java.lang.String类，能否使用？"),a("ul",null,[a("li",null,"可以自定义包名不为java.lang的String类，并区别包名正常使用"),a("li",null,[n("自定义包名为java.lang的String类 "),a("ul",null,[a("li",null,"String类下写main方法：由于双亲委派模型，在加载String类时，会最终委派给Bootstrap ClassLoader去加载，加载的是rt.jar包中的那个java.lang.String，而rt.jar包中的String类是没有main方法的，因此报错误"),a("li",null,"启动类也在java.lang包下：这里与是否用到String类无关，会报 Prohibited package name: java.lang错误。由于双亲委派，java.lang 包肯定早于自定义的java.lang 包的加载，就会冲突."),a("li",null,"调用方法不在java.lang包中：此时由于双亲委派模型的存在，并不会加载到自定义的String类")])])]),a("hr"),a("ul",null,[a("li",null,"来自一线程序员Seven的探索与实践，持续学习迭代中~"),a("li",null,[n("本文已收录于我的个人博客："),a("a",{href:"https://www.seven97.top",target:"_blank",rel:"noreferrer"},"https://www.seven97.top")])])],-1),a("h3",{id:"类加载器",tabindex:"-1"},[n("类加载器 "),a("a",{class:"header-anchor",href:"#类加载器","aria-label":'Permalink to "类加载器"'},"​")],-1),a("details",{class:"details custom-block"},[a("summary",null,"什么是类加载器？"),a("p",null,"类加载器（ClassLoader）是 Java 虚拟机（JVM）的一部分，用于将字节码文件加载到 JVM 运行时数据区中。 现有的类加载器基本都是 java.lang.ClassLoader 的子类，该类用于将指定的类找到或生成对应的字节码文件。 同时，类加载器负责加载程序所需的资源文件。")],-1),a("details",{class:"details custom-block"},[a("summary",null,"有哪些类加载器？"),a("ul",null,[a("li",null,"启动类加载器（Bootstrap ClassLoader）：不继承 ClassLoader。用于加载 JVM 运行时必备的核心类，如 JAVA_HOME/jre/lib 目录下的类。"),a("li",null,"扩展类加载器（Extension ClassLoader）：加载 JVM 扩展目录中的类，如 JAVA_HOME/jre/lib/ext 目录中的类。"),a("li",null,"应用程序类加载器（Application ClassLoader）：加载应用程序 classpath 目录中的类。"),a("li",null,"自定义类加载器：继承 ClassLoader 类，实现自定义类加载规则。")])],-1),a("h3",{id:"双亲委派模型-parent-delegation-model",tabindex:"-1"},[n("双亲委派模型 (Parent Delegation Model) "),a("a",{class:"header-anchor",href:"#双亲委派模型-parent-delegation-model","aria-label":'Permalink to "双亲委派模型 (Parent Delegation Model)"'},"​")],-1),a("details",{class:"details custom-block"},[a("summary",null,"什么是双亲委派模型？"),a("p",null,"每个类加载器在尝试加载类或资源时，会首先检查请求加载的类型是否已经被加载过，若没有将这个任务委托给它的父加载器去完成。 只有当父加载器无法找到并加载请求的类时，子加载器才会尝试自己去加载该类。")],-1),a("details",{class:"details custom-block"},[a("summary",null,"双亲委派模型的优点？"),a("ul",null,[a("li",null,"避免类的重复加载：当父加载器已经加载了一个类时，子加载器不会再加载一次。"),a("li",null,"避免恶意代码：防止恶意代码替换 JDK 中的核心类。")])],-1),a("details",{class:"details custom-block"},[a("summary",null,"如何破坏双亲委派模型？"),a("p",null,"在某些场景中，父类加载器加载不到子模块中的类，这时需要打破双亲委派模型。"),a("ul",null,[a("li",null,"重写 loadClass()方法：重写 loadClass()方法，让当前 ClassLoader 先尝试加载类。"),a("li",null,"重写 findClass()方法：findClass() 只会被 loadClass() 调用，不会委派给父类。重写 findClass()方法，自定义加载规则。"),a("li",null,"使用线程上下文类加载器：通过 Thread.currentThread().setContextClassLoader()设置线程上下文类加载器。 临时替换当前线程的类加载器，使得类加载器不再遵循双亲委派模型。如：Tomcat 的 Web 应用程序类加载器就是通过线程上下文类加载器实现的。")])],-1)])),"main-header":l(()=>[t(e.$slots,"main-header")]),"main-header-after":l(()=>[t(e.$slots,"main-header-after")]),"main-nav":l(()=>[t(e.$slots,"main-nav")]),"main-content-before":l(()=>[t(e.$slots,"main-content-before")]),"main-content":l(()=>[t(e.$slots,"main-content")]),"main-content-after":l(()=>[t(e.$slots,"main-content-after")]),"main-nav-before":l(()=>[t(e.$slots,"main-nav-before")]),"main-nav-after":l(()=>[t(e.$slots,"main-nav-after")]),comment:l(()=>[t(e.$slots,"comment")]),footer:l(()=>[t(e.$slots,"footer")]),aside:l(()=>[t(e.$slots,"aside")]),"aside-custom":l(()=>[t(e.$slots,"aside-custom")]),default:l(()=>[t(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{N as default,j as usePageData};
