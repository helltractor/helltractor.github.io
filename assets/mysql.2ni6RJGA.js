import{_ as C}from"./ValaxyMain.vue_vue_type_style_index_0_lang.CmWMQfP7.js";import{_ as p}from"./ValaxyMermaid.vue_vue_type_script_setup_true_lang.BTBzuEFe.js";import"./chunks/@vueuse/motion.BsBBmBGk.js";import{d as L,a as x,u as S}from"./chunks/vue-router.CTK7L64s.js";import{X as R,b_ as e,bB as Q,b3 as k,be as o,_ as l,a6 as d,a5 as n,aM as g,b5 as B}from"./framework.BXq2oTmp.js";import"./app.C0sh_VBo.js";import"./chunks/dayjs.C6BNYsUE.js";import"./chunks/vue-i18n.lfRrKsMF.js";import"./chunks/pinia.C_YCGfgp.js";import"./chunks/nprogress.DdFZ7jLs.js";import"./YunComment.vue_vue_type_style_index_0_lang.Cd8-cGEE.js";import"./index.dXt3ZyM3.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.DDanGzXB.js";import"./post.bpTe-d7H.js";const A={class:"details custom-block"},M=L("/jobs/question/mysql",async i=>JSON.parse('{"title":"MySQL","description":"","frontmatter":{"title":"MySQL","date":"2025-04-11 15:16:50"},"headers":[],"relativePath":"pages/jobs/question/mysql.md","lastUpdated":null}'),{lazy:(i,s)=>i.name===s.name}),h={__name:"mysql",setup(i,{expose:s}){var y;const{data:m}=M(),b=S(),I=x(),a=Object.assign(I.meta.frontmatter||{},((y=m.value)==null?void 0:y.frontmatter)||{});return b.currentRoute.value.data=m.value,B("valaxy:frontmatter",a),globalThis.$frontmatter=a,s({frontmatter:{title:"MySQL",date:"2025-04-11 15:16:50"}}),(u,t)=>{const r=p,f=C;return k(),R(f,{frontmatter:Q(a)},{"main-content-md":e(()=>[t[3]||(t[3]=l("h2",{id:"体系结构",tabindex:"-1"},[n("体系结构 "),l("a",{class:"header-anchor",href:"#体系结构","aria-label":'Permalink to "体系结构"'},"​")],-1)),d(r,g({code:"Z3JhcGggVEQ7CiAgQVvlrqLmiLfnq68gQ2xpZW50XSAtLT586L-e5o6lfCDov57mjqXlsYIKICDov57mjqXlsYIgLS0-fFNRTOino-aekHwg6Kej5p6Q5LiO5LyY5YyW5bGCCiAg6Kej5p6Q5LiO5LyY5YyW5bGCIC0tPnzlrZjlgqjlvJXmk47osIPnlKh8IOWtmOWCqOW8leaTjuWxggogIOWtmOWCqOW8leaTjuWxgiAtLT586K6_6Zeu56OB55uYfCBFW-eJqeeQhuWtmOWCqCBEaXNrXQoKICBzdWJncmFwaCDov57mjqXlsYIKICAgICAgZGlyZWN0aW9uIExSCiAgICAgIEIxW-i_nuaOpeeuoeeQhl0gLS0-IEIyW-adg-mZkOmqjOivgV0KICAgICAgQjIgLS0-IEIzW-e6v-eoi-euoeeQhl0KICBlbmQKCiAgc3ViZ3JhcGgg6Kej5p6Q5LiO5LyY5YyW5bGCCiAgICAgIGRpcmVjdGlvbiBMUgogICAgICBDMVtTUUwg6Kej5p6QIFBhcnNlcl0KICAgICAgQzJb5p-l6K-i5LyY5YyW5ZmoIE9wdGltaXplcl0KICAgICAgQzNb5p-l6K-i5omn6KGM6K6h5YiSIEV4ZWN1dG9yXQogICAgICBDMSAtLT4gQzIgLS0-IEMzCiAgZW5kCgogIHN1YmdyYXBoIOWtmOWCqOW8leaTjuWxggogICAgICBEMVvlrZjlgqjlvJXmk45dCiAgICAgIEQxIC0tPiBEMTFbIklubm9EQiAo6buY6K6kKSJdCiAgICAgIEQxIC0tPiBEMTJbTXlJU0FNXQogICAgICBEM1vml6Xlv5fnrqHnkIZdCiAgICAgIEQzIC0tPnzkuovliqHml6Xlv5d8IEQzMVtSZWRvIExvZ10KICAgICAgRDMgLS0-fOWbnua7muaXpeW_l3wgRDMyW1VuZG8gTG9nXQogICAgICBEMyAtLT585LqM6L-b5Yi25pel5b-XfCBEMzNbQmlubG9nXQogIGVuZAoKICBFIC0tPnzmlbDmja7mlofku7Z8IEUxWy5pYmQg5pWw5o2u5paH5Lu2XQogIEUgLS0-fOe0ouW8leaWh-S7tnwgRTJbLmZybSDooajnu5PmnoTmlofku7ZdCiAgRSAtLT585pel5b-X5paH5Lu2fCBFM1tCaW5sb2cgLyBSZWRvIExvZ10"},{}),null,16),t[4]||(t[4]=l("hr",null,null,-1)),t[5]||(t[5]=l("ul",null,[l("li",null,"MySQL 可以不指定主键建表吗，背后的逻辑是什么"),l("li",null,"建唯一索引，插入数据时是怎么处理的"),l("li",null,"重复插入会报错，是怎么处理的")],-1)),t[6]||(t[6]=l("h2",{id:"索引",tabindex:"-1"},[n("索引 "),l("a",{class:"header-anchor",href:"#索引","aria-label":'Permalink to "索引"'},"​")],-1)),t[7]||(t[7]=l("details",{class:"details custom-block"},[l("summary",null,"索引的优缺点?"),l("ul",null,[l("li",null,[n("优点： "),l("ul",null,[l("li",null,"大大加快数据的检索速度（减少检索的数据量），减少磁盘 I/O 次数。"),l("li",null,"通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。")])]),l("li",null,[n("缺点： "),l("ul",null,[l("li",null,"创建索引和维护索引要耗费时间，降低数据的维护速度。"),l("li",null,"索引需要占用物理空间，降低数据存储量。")])])])],-1)),t[8]||(t[8]=l("details",{class:"details custom-block"},[l("summary",null,"索引的数据结构"),l("p",null,"常见的索引数据结构包括： Hash 表、二叉查找树（BST）、平衡二叉查找树（AVL）、红黑树、B 树 和 B+ 树等。"),l("p",null,"目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。")],-1)),t[9]||(t[9]=l("details",{class:"details custom-block"},[l("summary",null,"B 树和 B+树两者有何异同呢？使用 B+树的好处？"),l("p",null,"B 树和 B+ 树都是多路平衡查找树，即每个节点有多个子节点。B 树和 B+ 树的区别主要在于："),l("ul",null,[l("li",null,"B 树的所以节点存储键值，B+树的非叶子节点只存储键，只有叶子节点存储键值。"),l("li",null,"B 树的叶子节点相互独立，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。"),l("li",null,"B 树的检索是范围内的每个节点做二分查找，可能无需遍历到叶子节点，B+树的检索是范围内的每个节点都要遍历到叶子节点。"),l("li",null,"B 树的范围查询，首先找到要查找的下限，然后进行中序遍历，直到找到上限；B+树的范围查询，只需对叶子节点进行遍历。")]),l("p",null,"综上，B+ 树的优点在于，具有更少的 IO 次数，更稳定的查询效率，更适合范围查询。")],-1)),t[10]||(t[10]=l("details",{class:"details custom-block"},[l("summary",null,"什么是聚簇索引和非聚簇索引（底层存储方式）？"),l("ul",null,[l("li",null,"聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。准确来说，是将数据存储在叶子节点中。"),l("li",null,"非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。在叶子节点中存储叶子节点本身的索引值和主键值 （MyISAM 中存放是数据的地址值），有了主键值再进行一次回表操作，从聚簇索引中根据主键值定位数据位置。")])],-1)),t[11]||(t[11]=l("details",{class:"details custom-block"},[l("summary",null,"什么是覆盖索引和联合索引？"),l("ul",null,[l("li",null,"覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。"),l("li",null,"使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。")]),l("hr"),l("p",null,"在 InnoDB 存储引擎中，非主键索引的叶子节点包含的是主键的值。这意味着，当使用非主键索引进行查询时， 数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。")],-1)),t[12]||(t[12]=l("details",{class:"details custom-block"},[l("summary",null,"什么是最左前缀匹配原则?"),l("p",null,"最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。 如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。"),l("p",null,"最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。")],-1)),t[13]||(t[13]=l("details",{class:"details custom-block"},[l("summary",null,"那些情况适合创建索引的？"),l("ul",null,[l("li",null,[l("strong",null,"不为 NULL 的字段："),n(" 索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。 如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。")]),l("li",null,[l("strong",null,"被频繁查询的字段："),n(" 我们创建索引的字段应该是查询操作非常频繁的字段。")]),l("li",null,[l("strong",null,"被作为条件查询的字段："),n(" 被作为 WHERE 条件查询的字段，应该被考虑建立索引。")]),l("li",null,[l("strong",null,"频繁需要排序的字段："),n(" 索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。")]),l("li",null,[l("strong",null,"被经常频繁用于连接的字段："),n(" 经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键， 只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。")])])],-1)),t[14]||(t[14]=l("h2",{id:"事务管理",tabindex:"-1"},[n("事务管理 "),l("a",{class:"header-anchor",href:"#事务管理","aria-label":'Permalink to "事务管理"'},"​")],-1)),l("details",A,[t[0]||(t[0]=l("summary",null,"事务的四大特性",-1)),t[1]||(t[1]=l("p",null,"事务是一组操作的集合，要么全部执行成功，要么全部回滚。事务的 ACID 特性包括：",-1)),t[2]||(t[2]=l("ul",null,[l("li",null,"原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；"),l("li",null,"一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；"),l("li",null,"隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；"),l("li",null,"持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。")],-1)),d(r,g({code:"Zmxvd2NoYXJ0IFREOwogIHN1YmdyYXBoIEFJRAogICAgQShbQSDljp_lrZDmgKddKQogICAgSShbSSDpmpTnprvmgKddKQogICAgRChbRCDmjIHkuYXmgKddKQogIGVuZAoKICBBSUQgLS0-IEMoW-S4gOiHtOaAp10p"},{}),null,16)]),t[15]||(t[15]=l("details",{class:"details custom-block"},[l("summary",null,"并发事务可能出现的问题?"),l("ul",null,[l("li",null,"脏读：读取到未提交的数据。"),l("li",null,"不可重复度：多次读取数据，但在读取过程中，另一个事务修改了数据，导致多次读取的数据不一致。"),l("li",null,"幻读：多次读取数据，但在读取过程中，另一个事务插入或删除了数据，导致多次读取的查询数据总量不一致。"),l("li",null,"丢失修改：两个事务同时读取同一数据，其中一个事务修改了数据，另一个事务也修改了数据，导致其中一个事务的修改被覆盖。")]),l("hr"),l("p",null,"不可重复读和幻读的区别在于："),l("ul",null,[l("li",null,[n("不可重复读是读取了其他事务更改的数据，针对"),l("strong",null,"update"),n("操作")]),l("li",null,"解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。"),l("li",null,[n("幻读是读取了其他事务新增的数据，针对"),l("strong",null,"insert"),n("与"),l("strong",null,"delete"),n("操作 "),l("ul",null,[l("li",null,"解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。")])])])],-1)),t[16]||(t[16]=l("details",{class:"details custom-block"},[l("summary",null,"什么是事务的隔离级别?"),l("p",null,"SQL 标准定义了四种事务隔离级别，不同的隔离级别对并发事务的影响不同，包括："),l("ul",null,[l("li",null,[l("strong",null,"读未提交（Read Uncommitted，RU）"),n("：允许脏读，一个事务可以读取到另一个事务未提交的数据。")]),l("li",null,[l("strong",null,"读已提交（Read Committed，RC）"),n("：只能读取到已提交的数据，避免脏读，但可能出现不可重复读。")]),l("li",null,[l("strong",null,"可重复读（Repeatable Read，RR）"),n("：保证同一事务中多次读取的数据是一致的，除非数据是被本身事务自己修改的。")]),l("li",null,[l("strong",null,"串行化（Serializable）"),n("：最高隔离级别，保证事务串行执行，避免脏读、不可重复读和幻读。")])]),l("table",null,[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"left"}},"隔离级别"),l("th",{style:{"text-align":"left"}},"脏读"),l("th",{style:{"text-align":"left"}},"不可重复读"),l("th",{style:{"text-align":"left"}},"幻读")])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"left"}},"读未提交"),l("td",{style:{"text-align":"left"}},"✅"),l("td",{style:{"text-align":"left"}},"✅"),l("td",{style:{"text-align":"left"}},"✅")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"读已提交"),l("td",{style:{"text-align":"left"}},"❌"),l("td",{style:{"text-align":"left"}},"✅"),l("td",{style:{"text-align":"left"}},"✅")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"可重复读"),l("td",{style:{"text-align":"left"}},"❌"),l("td",{style:{"text-align":"left"}},"❌"),l("td",{style:{"text-align":"left"}},"✅")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"串行化"),l("td",{style:{"text-align":"left"}},"❌"),l("td",{style:{"text-align":"left"}},"❌"),l("td",{style:{"text-align":"left"}},"❌")])])]),l("hr"),l("p",null,"MySQL InnoDB 存储引擎默认的隔离级别是可重复读（Repeatable Read）。采用以下方式解决幻读问题的发生："),l("ul",null,[l("li",null,"快照读：在可重复读隔离级别下，通过 MVCC 机制，读取到的是快照数据，不会受到其他事务的影响。"),l("li",null,"当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行记录锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。")])],-1)),t[17]||(t[17]=l("details",{class:"details custom-block"},[l("summary",null,"解决幻读的方法"),l("ul",null,[l("li",null,"升级事务隔离级别：将隔离级别升级到 Serializable，保证事务串行执行，避免幻读。"),l("li",null,"使用锁机制：Next-Key Lock，保证不会出现幻读。")])],-1)),t[18]||(t[18]=l("h2",{id:"锁机制",tabindex:"-1"},[n("锁机制 "),l("a",{class:"header-anchor",href:"#锁机制","aria-label":'Permalink to "锁机制"'},"​")],-1)),t[19]||(t[19]=l("details",{class:"details custom-block"},[l("summary",null,"锁的分类与类型"),l("ul",null,[l("li",null,[n("锁的粒度 "),l("ul",null,[l("li",null,[n("行锁 "),l("ul",null,[l("li",null,"记录锁（Record Lock）：属于单个行记录上的锁。"),l("li",null,"间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。"),l("li",null,"临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。")])]),l("li",null,"表锁"),l("li",null,"页锁：锁定数据页")])]),l("li",null,[n("锁的类型 "),l("ul",null,[l("li",null,"共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。"),l("li",null,"排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。"),l("li",null,[n("意向锁（表锁） "),l("ul",null,[l("li",null,"意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。"),l("li",null,"意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。")])])])])])],-1)),t[20]||(t[20]=l("details",{class:"details custom-block"},[l("summary",null,"什么是死锁？如何避免死锁？"),l("p",null,"死锁是指两个或两个以上的事务之间互相等待对方具有的锁，同时持有对方需要的锁。"),l("ul",null,[l("li",null,[n("避免死锁 "),l("ul",null,[l("li",null,"控制资源获取顺序：事务按照一定顺序获取一系列锁，获取不到释放当前占有的锁。"),l("li",null,"控制锁的粒度或少用锁：通过将隔离等级从 RR 更改为 RC，避免间隙锁和 next-key 锁带来的死锁情况。"),l("li",null,"减少持有资源的时间：事务具有长时间锁的需求，可以将 SQL 语句集中在事务的最前面或最后面。")])]),l("li",null,[n("解决死锁 "),l("ul",null,[l("li",null,"目前的数据库都一般都具备自动干预死锁的能力。比如 mysql 中可以通过同等待图机制检测到死锁后选择回滚一个开销较小的事务来解决死锁; 还可以通过设置一个事务的超时时间来避免死锁；")])])])],-1)),t[21]||(t[21]=l("h2",{id:"mvcc-multi-version-concurrency-control",tabindex:"-1"},[n("MVCC (Multi-Version Concurrency Control) "),l("a",{class:"header-anchor",href:"#mvcc-multi-version-concurrency-control","aria-label":'Permalink to "MVCC (Multi-Version Concurrency Control)"'},"​")],-1)),t[22]||(t[22]=l("p",null,"多版本并发控制（MVCC）通过保存数据的多个版本来实现并发控制，避免了读写冲突。",-1)),t[23]||(t[23]=l("p",null,"MVCC只在 Read Committed 和 Repeatable Read两个隔离级别下工作，其他两个隔离级别和MVCC不兼容：",-1)),t[24]||(t[24]=l("ul",null,[l("li",null,"Read Uncommitted总是读取最新的记录行，不需要MVCC的支持；"),l("li",null,"Serializable 则会对所有读取的记录行都加锁，单靠MVCC无法完成;")],-1)),t[25]||(t[25]=l("details",{class:"details custom-block"},[l("summary",null,"MVCC 是如何实现的？"),l("p",null,"MVCC 的实现依赖于：隐藏字段、Read View、undo log。 在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性， 如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。 每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改。"),l("p",null,"隐藏字段："),l("ul",null,[l("li",null,"DB_TRX_ID：表示该行记录的创建或修改事务的 ID。"),l("li",null,"DB_ROLL_PTR：表示该行记录的回滚指针，指向 undo log 中的历史版本。"),l("li",null,"DB_ROW_ID：表示该行记录的唯一 ID。")]),l("p",null,"Read View：在某一时刻给事务系统的trx_sys打snapshot，把当时trx_sys状态（包括活跃读写事务数组）记下来， 之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性。")],-1)),t[26]||(t[26]=l("details",{class:"details custom-block"},[l("summary",null,"快照读与当前读的区别？"),l("p",null,[n("快照读："),l("strong",null,"读取的是记录的可见版本（可能是历史版本），不加锁。"),n(" MySQL中InnoDB存储引擎的快照读(Snapshot Read)是一种读取数据的方式，它可以在事务开始时创建一个数据快照，这个快照是一致性的，即读取在事务开始时或特定时间点之前提交的数据。 其实就是简单的select 操作。如：")]),l("ul",null,[l("li",null,[l("code",null,"select * from table where ?;")])]),l("p",null,[n("当前读："),l("strong",null,"读取的是记录的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发修改这条记录。"),n(" 其实就是特殊的读操作，比如插入、更新、删除属于当前读，需要加锁的也属于当前读。如：")]),l("ul",null,[l("li",null,[n("共享锁："),l("code",null,"select * from table where ? lock in share mode;")]),l("li",null,[n("排他锁："),l("code",null,"select * from table where ? for update;")]),l("li",null,[n("插入："),l("code",null,"insert into table values(?);")]),l("li",null,[n("更新："),l("code",null,"update table set ? where ?;")]),l("li",null,[n("删除："),l("code",null,"delete from table where ?;")])])],-1)),t[27]||(t[27]=l("details",{class:"details custom-block"},[l("summary",null,"RR 和 RC 下快照读的区别？"),l("p",null,"事务总能够读取到自己写入(update /insert /delete)的行记录。而其他事务的提交，则分情况。 RC模式，快照读总是能读到最新的行数据快照，当然，必须是已提交事务写入的。 RR模式，某个事务首次read记录的时间为T1，之后的操作不会读取到T1时间之后已提交事务写入的记录，以保证连续相同的read读到相同的结果集。 简单点说："),l("ul",null,[l("li",null,"RR下，事务在第一个Read操作时，会建立Read View，并贯穿整个事务的过程，保证了可重复读的效果。"),l("li",null,"RC下，事务在每次Read操作时，都会建立Read View，以保证获取到的都是数据库中最新的被Commit的值。")]),l("hr"),l("ul",null,[l("li",null,"作者：Brand"),l("li",null,[n("出处："),l("a",{href:"https://www.cnblogs.com/wzh2010/",target:"_blank",rel:"noreferrer"},"https://www.cnblogs.com/wzh2010/")])])],-1)),t[28]||(t[28]=l("h2",{id:"日志",tabindex:"-1"},[n("日志 "),l("a",{class:"header-anchor",href:"#日志","aria-label":'Permalink to "日志"'},"​")],-1)),t[29]||(t[29]=l("p",null,"MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。",-1)),t[30]||(t[30]=l("h3",{id:"redo-log",tabindex:"-1"},[n("redo log "),l("a",{class:"header-anchor",href:"#redo-log","aria-label":'Permalink to "redo log"'},"​")],-1)),t[31]||(t[31]=l("ul",null,[l("li",null,"redo log 属于物理日志。"),l("li",null,"redo log 是 InnoDB 存储引擎独有的，让 MySQL 拥有恢复崩溃的能力，保证数据的持久性。"),l("li",null,"写入机制：当对表数据进行更新时，首先查找 buffer pool，没有命中则从硬盘中以数据页的形式读取。事务执行时，redo log 通过记录“在某个数据页上做了什么修改”，写入 redo log buffer，事务提交时，判断是否刷盘到硬盘中的 redo.file。"),l("li",null,"存储形式：日志文件组，环形数组。")],-1)),t[32]||(t[32]=l("h3",{id:"binlog",tabindex:"-1"},[n("binlog "),l("a",{class:"header-anchor",href:"#binlog","aria-label":'Permalink to "binlog"'},"​")],-1)),t[33]||(t[33]=l("ul",null,[l("li",null,"binlog 属于逻辑日志。"),l("li",null,"binlog 会记录所有涉及更新数据的逻辑操作，并且是顺序写。保证了 MySQL 集群架构的数据一致性。"),l("li",null,"写入机制：事务执行时，将 binlog 写入 binlog cache，事务提交时，判断是否刷盘到硬盘中的 binlog 文件中。"),l("li",null,[n("存储形式 "),l("ul",null,[l("li",null,"statement：具体 SQL 语句；"),l("li",null,"row：具体 SQL 语句+具体数据；"),l("li",null,"mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。")])])],-1)),t[34]||(t[34]=l("h3",{id:"undo-log",tabindex:"-1"},[n("undo log "),l("a",{class:"header-anchor",href:"#undo-log","aria-label":'Permalink to "undo log"'},"​")],-1)),t[35]||(t[35]=l("ul",null,[l("li",null,"undo log 属于逻辑日志。"),l("li",null,"undo log 保证事务原子性。"),l("li",null,"存储形式：undo log 记录的时 SQL 语句，是已经执行的语句对应的回溯语句。undo log 信息会记录再 redo log 中，因为 undo log 也要实现持久性保护。undo log 是采用 segment（段）的方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment，包含在 rollback segment 中。"),l("li",null,"history list：history list 是 rollback segment header 的一部分，它的主要作用是记录所有已经提交但还没有被清理（purge）的事务的 undo log。这个列表使得 purge 线程能够找到并清理那些不再需要的 undo log 记录。")],-1)),d(r,g({code:"Z3JhcGggVEQ7CiAgc3ViZ3JhcGggcm9sbGJhY2sgc2VnbWVudAogICAgc3ViZ3JhcGggcm9sbGJhY2sgc2VnbWVudAogICAgICBzdWJncmFwaCBoaXN0b3J5IGxpc3QKICAgICAgICBlbmQKICAgIGVuZAogIGVuZA"},{}),null,16),t[36]||(t[36]=l("hr",null,null,-1)),t[37]||(t[37]=l("details",{class:"details custom-block"},[l("summary",null,"为什么需要两阶段提交？"),l("p",null,"为了保证逻辑日志和物理日志的一致性；如果没有二阶段提价的话；如果插入操作先提交了 redo log 此时 undo log 还没有进行写盘此时断电了；再次重启数据库后 bin log 就无法感知导致从数据库比主数据库少一条数据； 如果先写入 bin log 再写入 redo log, 如果 bin log 完成写入后崩溃那么 redo log 就无法感知未记录的事务, 就会导致从数据中有这个事务但是主数据中没有。"),l("hr"),l("ul",null,[l("li",null,"作者：不吃勤菜_Java 版"),l("li",null,[n("链接："),l("a",{href:"https://www.nowcoder.com/discuss/727194657410531328?sourceSSR=search",target:"_blank",rel:"noreferrer"},"https://www.nowcoder.com/discuss/727194657410531328?sourceSSR=search")]),l("li",null,"来源：牛客网")])],-1)),t[38]||(t[38]=l("h2",{id:"数据库优化",tabindex:"-1"},[n("数据库优化 "),l("a",{class:"header-anchor",href:"#数据库优化","aria-label":'Permalink to "数据库优化"'},"​")],-1)),t[39]||(t[39]=l("ul",null,[l("li",null,"数据库结构优化"),l("li",null,"MySQL 数据库 CPU 使用率飙升的原因"),l("li",null,"为什么要分库分表"),l("li",null,"分库分表的具体实施策略"),l("li",null,"分库分表存在那些问题"),l("li",null,"什么是 MySQL 主从复制"),l("li",null,"MySQL 主从复制的工作原理"),l("li",null,"MySQL 读写分离的实现方案")],-1)),t[40]||(t[40]=l("details",{class:"details custom-block"},[l("summary",null,"Explain 的作用是什么？"),l("p",null,"Explain 是 MySQL 提供的用于分析查询语句的工具，可以帮助开发人员分析查询语句的性能，找出可能存在的问题。 重要的关注指标包括：select_type、type、possible_keys、key、rows 等。"),l("table",null,[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"left"}},"字段"),l("th",{style:{"text-align":"left"}},"说明")])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"left"}},"id"),l("td",{style:{"text-align":"left"}},"查询的序列号，表示查询中执行 select 子句或操作表的顺序")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"select_type"),l("td",{style:{"text-align":"left"}},"查询的select子句类型，主要有：SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT 等")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"table"),l("td",{style:{"text-align":"left"}},"查询的表")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"type"),l("td",{style:{"text-align":"left"}},"查询的类型方式，主要有：system、const、eq_ref、ref、range、index、all 等")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"possible_keys"),l("td",{style:{"text-align":"left"}},"可能使用的索引，表示MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。这个趋向于指导性作用。")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"key"),l("td",{style:{"text-align":"left"}},"实际使用的索引，显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"key_len"),l("td",{style:{"text-align":"left"}},"使用的索引的长度")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"ref"),l("td",{style:{"text-align":"left"}},"显示索引的哪一列被使用了，如果可能的话，是一个常数")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"rows"),l("td",{style:{"text-align":"left"}},"MySQL 查询时预估扫描的行数")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"Extra"),l("td",{style:{"text-align":"left"}},"额外的信息，包括不适合在其他列中显示但是还是重要的信息")])])])],-1))]),"main-header":e(()=>[o(u.$slots,"main-header")]),"main-header-after":e(()=>[o(u.$slots,"main-header-after")]),"main-nav":e(()=>[o(u.$slots,"main-nav")]),"main-content-before":e(()=>[o(u.$slots,"main-content-before")]),"main-content":e(()=>[o(u.$slots,"main-content")]),"main-content-after":e(()=>[o(u.$slots,"main-content-after")]),"main-nav-before":e(()=>[o(u.$slots,"main-nav-before")]),"main-nav-after":e(()=>[o(u.$slots,"main-nav-after")]),comment:e(()=>[o(u.$slots,"comment")]),footer:e(()=>[o(u.$slots,"footer")]),aside:e(()=>[o(u.$slots,"aside")]),"aside-custom":e(()=>[o(u.$slots,"aside-custom")]),default:e(()=>[o(u.$slots,"default")]),_:3},8,["frontmatter"])}}};export{h as default,M as usePageData};
