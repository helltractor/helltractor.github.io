import{_ as k}from"./ValaxyMain.vue_vue_type_style_index_0_lang.CmWMQfP7.js";import{_ as f}from"./ValaxyMermaid.vue_vue_type_script_setup_true_lang.BTBzuEFe.js";import"./chunks/@vueuse/motion.BsBBmBGk.js";import{d as y,a as C,u as E}from"./chunks/vue-router.CTK7L64s.js";import{X as S,b_ as s,bB as A,b3 as B,be as t,_ as l,a6 as g,a5 as n,aM as p,b5 as D}from"./framework.BXq2oTmp.js";import"./app.C0sh_VBo.js";import"./chunks/dayjs.C6BNYsUE.js";import"./chunks/vue-i18n.lfRrKsMF.js";import"./chunks/pinia.C_YCGfgp.js";import"./chunks/nprogress.DdFZ7jLs.js";import"./YunComment.vue_vue_type_style_index_0_lang.Cd8-cGEE.js";import"./index.dXt3ZyM3.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.DDanGzXB.js";import"./post.bpTe-d7H.js";const h="/assets/redis-memory-eviction-policy.C-s6ytnF.png",N="/assets/redis-data-type.Dbr-u4uQ.png",v="/assets/redis-caching.qNiYolNW.png",F={class:"details custom-block"},O=y("/jobs/question/redis",async r=>JSON.parse('{"title":"Redis 与缓存","description":"","frontmatter":{"title":"Redis 与缓存","date":"2025-04-11 15:16:41"},"headers":[],"relativePath":"pages/jobs/question/redis/index.md","lastUpdated":null}'),{lazy:(r,a)=>r.name===a.name}),M={__name:"index",setup(r,{expose:a}){var d;const{data:o}=O(),b=E(),R=C(),u=Object.assign(R.meta.frontmatter||{},((d=o.value)==null?void 0:d.frontmatter)||{});return b.currentRoute.value.data=o.value,D("valaxy:frontmatter",u),globalThis.$frontmatter=u,a({frontmatter:{title:"Redis 与缓存",date:"2025-04-11 15:16:41"}}),(e,i)=>{const m=f,I=k;return B(),S(I,{frontmatter:A(u)},{"main-content-md":s(()=>[i[4]||(i[4]=l("h2",{id:"redis-remote-dictionary-server",tabindex:"-1"},[n("Redis (Remote Dictionary Server) "),l("a",{class:"header-anchor",href:"#redis-remote-dictionary-server","aria-label":'Permalink to "Redis (Remote Dictionary Server)"'},"​")],-1)),i[5]||(i[5]=l("ul",null,[l("li",null,"为什么购物车多读多写"),l("li",null,"集群环境下，Redis 内存里的数据怎么保证一致"),l("li",null,"如何实现 Redis 的定时机制")],-1)),i[6]||(i[6]=l("details",{class:"details custom-block"},[l("summary",null,"Redis 有那些客户端，有什么区别？"),l("ul",null,[l("li",null,"Jedis：是 Redis 官方推荐的 Java 客户端，基于连接池，线程安全。"),l("li",null,"Lettuce：是一个高性能的 Redis 客户端，基于 Netty，支持异步和同步操作，线程安全。"),l("li",null,"Redisson：是一个基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid）和分布式锁服务框架，提供了许多分布式对象和服务，如分布式集合、分布式对象、分布式锁、分布式服务等。"),l("li",null,"Spring Data Redis：是 Spring Data 项目的一部分，提供了对 Redis 的支持，简化了 Redis 的操作，提供了 RedisTemplate 和 StringRedisTemplate 两个模板类。")])],-1)),i[7]||(i[7]=l("details",{class:"details custom-block"},[l("summary",null,"Redis 的主从复制原理？"),l("p",null,"Redis 主从复制有全量复制和部分复制两种方式。第一次连接或主库内存丢失时，会触发全量复制，主库生成 RDB 文件并发送给从库； 断线重连时，如果 offset 在主库复制缓冲区中还能找到，就会触发部分复制，只同步这段缺失的数据，避免了大规模数据传输，提高了系统的可用性。")],-1)),i[8]||(i[8]=l("details",{class:"details custom-block"},[l("summary",null,"Redis的过期策略？"),l("p",null,"Redis 的过期策略主要有三种："),l("ul",null,[l("li",null,"定时删除：Redis 会在设置过期时间时，使用定时器定期检查过期的键值对，并删除它们。"),l("li",null,"惰性删除：Redis 在访问键值对时，会检查该键值对是否过期，如果过期则删除它。"),l("li",null,"定期删除：Redis 会定期随机抽取一些键值对，检查它们是否过期，如果过期则删除它们。")]),l("p",null,"Redis 使用的过期删除策略是「惰性删除+定期删除」，删除的对象是已过期的 key。")],-1)),i[9]||(i[9]=l("details",{class:"details custom-block"},[l("summary",null,"Redis的内存淘汰策略？"),l("p",null,[n("内存淘汰策略是解决内存过大的问题，当 Redis 内存使用超过 maxmemory 限制时，Redis 会根据配置的淘汰策略来删除一些键值对，以释放内存。 "),l("img",{src:h,alt:"redis-memory-eviction-policy"})]),l("hr"),l("ul",null,[l("li",null,"作者：Brand"),l("li",null,[n("出处："),l("a",{href:"https://www.cnblogs.com/wzh2010/",target:"_blank",rel:"noreferrer"},"https://www.cnblogs.com/wzh2010/")])])],-1)),i[10]||(i[10]=l("details",{class:"details custom-block"},[l("summary",null,"Redis 为什么这么快?"),l("p",null,"Redis 之所以快，主要有以下几个原因："),l("ul",null,[l("li",null,[l("strong",null,"基于内存"),n("：Redis 数据存储在内存中，读写速度快。")]),l("li",null,[l("strong",null,"单线程"),n("：Redis 是单线程模型，避免了多线程的频繁上下文切换。")]),l("li",null,[l("strong",null,"非阻塞 I/O"),n("：Redis 使用 epoll 作为 I/O 多路复用技术，非阻塞 I/O。")]),l("li",null,[l("strong",null,"数据结构"),n("：Redis 使用了高效的数据结构，如哈希表、跳表、链表等。")]),l("li",null,[l("strong",null,"持久化"),n("：Redis 支持 RDB 和 AOF 两种持久化机制，保证数据持久化。")]),l("li",null,[l("strong",null,"集群"),n("：Redis 支持主从复制、哨兵和集群模式，提高了可用性和扩展性。")])]),l("hr"),l("p",null,"redis 是单线程模型，这样避免的多线程的上下文切换和锁竞争问题，同时通过非阻塞 I/O 和事件驱动模型来处理高并发请求。 另外数据存储在内存中，读写速度快，使用高效的数据结构，如哈希表、跳表、链表等，保证了数据的高效存取。")],-1)),i[11]||(i[11]=l("details",{class:"details custom-block"},[l("summary",null,"Redis 旁路缓存（Cache Aside）和写回缓存（Write Back）的区别"),l("ul",null,[l("li",null,[l("strong",null,"旁路缓存（Cache Aside）"),n("：读取数据时，先从缓存中读取，如果缓存中没有数据，再从数据库中读取，然后将数据写入缓存。更新数据时，"),l("strong",null,"先更新数据库，再删除缓存"),n("。")]),l("li",null,[l("strong",null,"写回缓存（Write Back）"),n("：读取数据时与旁路缓存一致。更新数据时，"),l("strong",null,"先更新缓存，再更新数据库"),n("。")])])],-1)),i[12]||(i[12]=l("details",{class:"details custom-block"},[l("summary",null,"redis 怎么实现分布式锁，setnx 有哪些参数？"),l("p",null,"Redis 分布式锁 通常通过 SETNX（Set if Not Exists） 命令实现。"),l("div",{style:{"max-height":"300px"},class:"language-bash vp-adaptive-theme line-numbers-mode"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"bash"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"SET"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," key"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," value"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," NX"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," PX"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," seconds")])])]),l("button",{class:"collapse"}),l("div",{class:"line-numbers-wrapper","aria-hidden":"true"},[l("span",{class:"line-number"},"1"),l("br")])]),l("ul",null,[l("li",null,"key：锁的标识值"),l("li",null,"value：唯一标识，用于判断锁的归属"),l("li",null,"NX：只在键不存在时，才对键进行设置操作"),l("li",null,"PX seconds：设置键的过期时间，防止锁忘记释放")])],-1)),i[13]||(i[13]=l("details",{class:"details custom-block"},[l("summary",null,"redisson 是怎么确定锁的拥有者的？"),l("ul",null,[l("li",null,"唯一标识：使用 UUID 作为 value 参数，设置唯一标识，用于判断锁的归属。"),l("li",null,"看门狗机制：leaseTime没有设置时，Redisson 会使用 30 秒作为默认的 leaseTime，同时启动一个看门狗线程，每隔 10 秒续期一次，避免锁过期。"),l("li",null,"可重入锁：同一线程多次加锁时，Redisson 会维护一个锁的重入计数器，避免阻塞。")])],-1)),i[14]||(i[14]=l("h3",{id:"数据类型",tabindex:"-1"},[n("数据类型 "),l("a",{class:"header-anchor",href:"#数据类型","aria-label":'Permalink to "数据类型"'},"​")],-1)),i[15]||(i[15]=l("p",null,"Redis 支持多种数据类型：",-1)),i[16]||(i[16]=l("ul",null,[l("li",null,"字符串/REDIS_STRING：适用于 缓存、计数、共享Session、IP统计、分布式锁等。"),l("li",null,"列表/REDIS_LIST： 链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表）。"),l("li",null,"哈希表/REDIS_HASH： 购物车信息、用户信息、Hash类型的(key, field, value)存储对象等。"),l("li",null,"集合/REDIS_SET：无序的唯一的键值结构： 好友、关注、粉丝、感兴趣的人集合等。"),l("li",null,"有序集合/REDIS_ZSET：访问排行榜、点赞排行、粉丝数排行等。")],-1)),i[17]||(i[17]=l("p",null,"数据结构：基于不同业务场景的高效数据结构",-1)),i[18]||(i[18]=l("ul",null,[l("li",null,"动态字符串(REDIS_STRING)：整数(REDIS_ENCODING_INT)、字符串(REDIS_ENCODING_RAW)"),l("li",null,"双端列表(REDIS_ENCODING_LINKEDLIST)"),l("li",null,"压缩列表(REDIS_ENCODING_ZIPLIST)"),l("li",null,"跳跃表(REDIS_ENCODING_SKIPLIST)"),l("li",null,"哈希表(REDIS_HASH)"),l("li",null,"整数集合(REDIS_ENCODING_INTSET)")],-1)),i[19]||(i[19]=l("hr",null,null,-1)),i[20]||(i[20]=l("figure",null,[l("img",{src:N,alt:"redis-data-type.png",loading:"lazy",decoding:"async"})],-1)),i[21]||(i[21]=l("ul",null,[l("li",null,"Redis 底层怎么实现的"),l("li",null,"hashtable 是怎样实现的"),l("li",null,"ziplist 怎样实现的")],-1)),i[22]||(i[22]=l("h3",{id:"io-模型",tabindex:"-1"},[n("IO 模型 "),l("a",{class:"header-anchor",href:"#io-模型","aria-label":'Permalink to "IO 模型"'},"​")],-1)),i[23]||(i[23]=l("p",null,"Redis 使用的是 I/O 多路复用模型，多路复用指的是：多个socket连接复用一个线程。这种模式下，内核不会去监视应用程序的连接，而是监视文件描述符。当客户端发起请求的时候，会生成不同事件类型的套接字。",-1)),i[24]||(i[24]=l("p",null,"而在服务端，因为使用了 I/O 多路复用技术，所以不是阻塞式的同步执行，而是将消息放入 socket 队列（参考下图的 I/O Multiplexing module），然后通过 File event Dispatcher 将其转发到不同的事件处理器上，如accept、read、send。",-1)),g(m,p({code:"Z3JhcGggTFI7CiAgc3ViZ3JhcGggIlNvY2tldCIKICAgIGZkMSgoZmQgMSkpCiAgICBmZDIoKGZkIDIpKQogICAgZmQzKChmZCAzKSkKICAgIGZkTigoZmQgTikpCiAgZW5kCgogIHN1YmdyYXBoICJJL08gTXVsdGlwbGV4aW5nIG1vZHVsZSIKICAgIGRpcmVjdGlvbiBUQgogICAgc29ja2V0MVtTb2NrZXQgMV0KICAgIHNvY2tldDJbU29ja2V0IDJdCiAgICBzb2NrZXQzW1NvY2tldCAzXQogICAgc29ja2V0TltTb2NrZXQgTl0KICBlbmQKCiAgZmQxIC0tPiBzb2NrZXQxCiAgZmQyIC0tPiBzb2NrZXQyCiAgZmQzIC0tPiBzb2NrZXQzCiAgZmROIC0tPiBzb2NrZXROCgogIHNvY2tldDEgLS0-IENbRmlsZSBldmVudCBEaXNwYXRjaGVyXQogIHNvY2tldDIgLS0-IEMKICBzb2NrZXQzIC0tPiBDCiAgc29ja2V0TiAtLT4gQwogIEMgLS0-IERbRXZlbnQgSGFuZGxlcl0KICBEIC0tPiBEMVsiYWNjZXB0KCkiXQogIEQgLS0-IEQyWyJyZWFkKCkiXQogIEQgLS0-IEQzWyJzZW5kKCkiXQ"},{}),null,16),i[25]||(i[25]=l("h3",{id:"持久化机制",tabindex:"-1"},[n("持久化机制 "),l("a",{class:"header-anchor",href:"#持久化机制","aria-label":'Permalink to "持久化机制"'},"​")],-1)),i[26]||(i[26]=l("p",null,"Redis 支持两种持久化机制：",-1)),i[27]||(i[27]=l("ul",null,[l("li",null,[l("strong",null,"RDB（Redis DataBase）Snapshot"),n("：Redis在指定的时间间隔内，将内存中的数据集快照定格下来，写入磁盘，并存储在副本文件中。当Redis重启时，这些快照文件会被自动读取并恢复到内存中。 "),l("ul",null,[l("li",null,[l("strong",null,"SAVE"),n("：阻塞式保存，Redis会阻塞所有的请求，直到RDB文件生成完成。")]),l("li",null,[l("strong",null,"BGSAVE"),n("：非阻塞式保存，Redis会fork一个子进程来生成RDB文件，主进程继续处理请求。")]),l("li",null,"优点：以二进制格式+数据压缩的方式存储数据，节省空间；恢复速度快。"),l("li",null,"缺点：无法实时持久化，每次创建子进程，频繁操作磁盘，性能开销大；数据丢失风险：如果Redis在RDB文件生成完成之前崩溃，则会丢失所有未保存的数据；无法兼容新旧版本rdb文件。")])]),l("li",null,[l("strong",null,"AOF（Append Only File）"),n("：以独立日志的方式存储了 Redis 服务器的顺序指令序列，并只记录对内存进行修改的指令。 "),l("ul",null,[l("li",null,"优点：实时持久化，数据丢失风险小；支持增量备份；可以使用 Redis 的命令行工具进行查看和编辑。"),l("li",null,"缺点：AOF 文件体积较大，恢复速度慢；性能开销大；需要定期重写 AOF 文件。"),l("li",null,"重写机制：Redis 会在后台异步重写 AOF 文件，避免阻塞主线程。重写时，Redis 会创建一个新的 AOF 文件，将当前内存中的数据以 Redis 协议格式写入新的 AOF 文件中，然后将旧的 AOF 文件替换为新的 AOF 文件。"),l("li",null,[l("strong",null,"混合持久化"),n("：RDB + AOF，就是在 AOF 重写 时，把当前数据快照 + 后续写入命令 一起保存到 AOF 文件里。")])])])],-1)),i[28]||(i[28]=l("hr",null,null,-1)),i[29]||(i[29]=l("ul",null,[l("li",null,"重写时，当前写入命令会缓存到 auf_rewrite_buf 中，等到重写完成后，再将 auf_rewrite_buf 中的命令写入新的 AOF 文件中。"),l("li",null,"RDB提供了快照模式，记录某个时间的Redis内存状态。RDB设计了 bgsave 和写时复制，尽可能避免执行快照期间对读写指令的影响，但是频繁快照会给磁盘带来压力以及 fork 阻塞主线程。需把握频率。"),l("li",null,"AOF 日志存储了 Redis 服务的顺序指令序列，通过重放（replay）指令来写入日志文件，并通过写回策略来避免高频读写给Redis带来压力。"),l("li",null,"RDB快照的照片时间间隔，必然会带来数据缺失，如果允许分钟级别的数据丢失，可以只使用 RDB。"),l("li",null,"如果只用 AOF，写回策略优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。"),l("li",null,"数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择。")],-1)),i[30]||(i[30]=l("h3",{id:"参考",tabindex:"-1"},[n("参考 "),l("a",{class:"header-anchor",href:"#参考","aria-label":'Permalink to "参考"'},"​")],-1)),i[31]||(i[31]=l("ul",null,[l("li",null,[l("a",{href:"https://redis.io/docs/latest/develop/data-types/",target:"_blank",rel:"noreferrer"},"Understand Redis data types")]),l("li",null,[l("a",{href:"https://www.runoob.com/redis/redis-data-types.html",target:"_blank",rel:"noreferrer"},"Redis 数据类型")]),l("li",null,[l("a",{href:"https://www.cnblogs.com/keeya/p/14332131.html#watch-dog-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%BB%B6%E6%9C%9F%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noreferrer"},"Redisson 分布式锁实战与 watch dog 机制解读")]),l("li",null,[l("a",{href:"https://redisson.pro/glossary/redis-lock.html",target:"_blank",rel:"noreferrer"},"What is a Redis lock?")]),l("li",null,[l("a",{href:"https://www.cnblogs.com/wzh2010/p/17205505.html",target:"_blank",rel:"noreferrer"},"Redis系列24：Redis使用规范")])],-1)),i[32]||(i[32]=l("h2",{id:"缓存",tabindex:"-1"},[n("缓存 "),l("a",{class:"header-anchor",href:"#缓存","aria-label":'Permalink to "缓存"'},"​")],-1)),i[33]||(i[33]=l("details",{class:"details custom-block"},[l("summary",null,"缓存预热是什么"),l("p",null,"答：缓存预热是在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，可采用后台更新机制。")],-1)),l("details",F,[i[0]||(i[0]=l("summary",null,"超卖问题是什么，应该怎么解决？",-1)),i[1]||(i[1]=l("p",null,"以证券交易系统为例",-1)),g(m,p({code:"Zmxvd2NoYXJ0IExSCiAgQVvmkq7lkIjlvJXmk45dIC0tPiBCW1JlZGlzIOe8k-WtmF0KICBCIC0tPiBDW015U1FMIOaVsOaNruW6k10"},{}),null,16),i[2]||(i[2]=l("hr",null,null,-1)),i[3]||(i[3]=l("ul",null,[l("li",null,"超卖问题：在高并发交易场景下，撮合系统没有正确更新和同步库存数据，导致同一批股票被多次卖出。"),l("li",null,[n("根本原因： "),l("ul",null,[l("li",null,[l("strong",null,"并发问题"),n("：多个线程同时读取库存数据，判断库存充足后，同时更新库存。")]),l("li",null,[l("strong",null,"缓存问题"),n("：缓存和数据库数据不一致，缓存数据未正确更新。")]),l("li",null,[l("strong",null,"事务问题"),n("：事务未正确提交或回滚，导致库存数据未正确更新。")]),l("li",null,[l("strong",null,"撮合引擎问题"),n("：撮合引擎处理顺序错误。")])])]),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,[l("strong",null,"悲观锁"),n("：在更新库存时加锁，保证同一时间只有一个线程更新库存。")]),l("li",null,[l("strong",null,"乐观锁"),n("：在更新库存时，先查询库存，再更新库存，保证库存不为负数。")]),l("li",null,[l("strong",null,"消息队列"),n("：将用户的购买请求放入消息队列，异步处理，保证库存不为负数。")]),l("li",null,[l("strong",null,"冻结库存"),n("：在用户下单时，先冻结库存，等订单撮合成功后再扣减库存。")])])])],-1))]),i[34]||(i[34]=l("ul",null,[l("li",null,"内存泄露具体发生在哪"),l("li",null,"栈内存泄漏和堆内存泄漏的区别")],-1)),i[35]||(i[35]=l("h2",{id:"缓存三剑客",tabindex:"-1"},[n("缓存三剑客 "),l("a",{class:"header-anchor",href:"#缓存三剑客","aria-label":'Permalink to "缓存三剑客"'},"​")],-1)),i[36]||(i[36]=l("details",{class:"details custom-block"},[l("summary",null,"没获取到锁的线程怎么处理？"),l("ol",null,[l("li",null,"重试机制，等待一段时间后再次尝试获取锁，或使用指数退避算法"),l("li",null,"直接抛出异常提示用户稍后再试"),l("li",null,"如果缓存中有逻辑过期时间，可以在锁争抢失败时直接返回过期数据，同时后台异步更新")])],-1)),i[37]||(i[37]=l("h3",{id:"缓存穿透",tabindex:"-1"},[n("缓存穿透 "),l("a",{class:"header-anchor",href:"#缓存穿透","aria-label":'Permalink to "缓存穿透"'},"​")],-1)),i[38]||(i[38]=l("ul",null,[l("li",null,"现象：请求访问缓存和数据库中都不存在的 key，每次请求都会直接达到数据库，导致数据库压力激增"),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,"布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉"),l("li",null,"空值过滤：缓存层增加一个空值的标记，当存储层没有数据时，缓存层也会将这个空值标记存入缓存，但是会设置一个较短的过期时间（TTL）"),l("li",null,"限流保护：对异常频繁的请求进行 IP 或验证码的验证")])])],-1)),i[39]||(i[39]=l("h3",{id:"缓存击穿",tabindex:"-1"},[n("缓存击穿 "),l("a",{class:"header-anchor",href:"#缓存击穿","aria-label":'Permalink to "缓存击穿"'},"​")],-1)),i[40]||(i[40]=l("ul",null,[l("li",null,"现象：某个热点 key 过期，大量并发请求同时访问数据库，导致数据库瞬间承受高负载"),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,"互斥锁：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么直接返回空值或默认值"),l("li",null,"后台更新缓存：不给热点数据设置过期时间，由后台线程异步更新缓存，或者在在热点数据准备要过期前，提前通知后台线程更新缓存以及设置过期时间")])])],-1)),i[41]||(i[41]=l("h3",{id:"缓存雪崩",tabindex:"-1"},[n("缓存雪崩 "),l("a",{class:"header-anchor",href:"#缓存雪崩","aria-label":'Permalink to "缓存雪崩"'},"​")],-1)),i[42]||(i[42]=l("ul",null,[l("li",null,"现象：缓存层的大量数据同时过期，导致请求直接访问数据库，数据库压力激增"),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,"缓存集群+数据库集群：通过多台机器部署缓存和数据库，提高系统的容错性"),l("li",null,"随机过期时间：缓存数据的过期时间设置随机值，防止同一时间大量数据过期现象"),l("li",null,"互斥锁：锁住更新缓存的资源，保证只有一个线程去更新缓存，并设置锁的超时时间"),l("li",null,"后台更新缓存（缓存预热）：业务线程不负责更新缓存，而是由后台线程负责定时更新缓存，或者在业务线程发现缓存过期时异步更新缓存")])])],-1)),i[43]||(i[43]=l("h3",{id:"小结",tabindex:"-1"},[n("小结 "),l("a",{class:"header-anchor",href:"#小结","aria-label":'Permalink to "小结"'},"​")],-1)),i[44]||(i[44]=l("figure",null,[l("img",{src:v,alt:"redis-caching.png",loading:"lazy",decoding:"async"})],-1)),i[45]||(i[45]=l("h3",{id:"参考-1",tabindex:"-1"},[n("参考 "),l("a",{class:"header-anchor",href:"#参考-1","aria-label":'Permalink to "参考"'},"​")],-1)),i[46]||(i[46]=l("ul",null,[l("li",null,[l("a",{href:"https://www.cnblogs.com/wzh2010/p/13874211.html",target:"_blank",rel:"noreferrer"},"架构与思维：一次缓存雪崩的灾难复盘")])],-1)),i[47]||(i[47]=l("h2",{id:"缓存策略",tabindex:"-1"},[n("缓存策略 "),l("a",{class:"header-anchor",href:"#缓存策略","aria-label":'Permalink to "缓存策略"'},"​")],-1)),i[48]||(i[48]=l("h3",{id:"旁路缓存-cache-aside",tabindex:"-1"},[n("旁路缓存（Cache Aside） "),l("a",{class:"header-anchor",href:"#旁路缓存-cache-aside","aria-label":'Permalink to "旁路缓存（Cache Aside）"'},"​")],-1)),i[49]||(i[49]=l("ul",null,[l("li",null,[l("strong",null,"读取数据"),n("：先从缓存中读取，如果缓存中没有数据，再从数据库中读取，然后将数据写入缓存")]),l("li",null,[l("strong",null,"更新数据"),n("：先更新数据库，再同步更新或删除缓存")])],-1)),i[50]||(i[50]=l("h3",{id:"更新数据库-更新缓存",tabindex:"-1"},[n("更新数据库+更新缓存 "),l("a",{class:"header-anchor",href:"#更新数据库-更新缓存","aria-label":'Permalink to "更新数据库+更新缓存"'},"​")],-1)),i[51]||(i[51]=l("ul",null,[l("li",null,[l("strong",null,"先更新数据库，再更新缓存"),n("和"),l("strong",null,"先更新缓存，再更新数据库"),n("：都存在并发问题，当两个请求并发更新同一条数据时，可能会出现缓存和数据库数据不一致的情况")]),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,"分布式锁：保证同一时间只有一个线程更新缓存，其他线程等待锁释放后再更新缓存"),l("li",null,"TTL：设置缓存的过期时间，保证缓存数据在一定时间内有效，过期后再更新缓存")])])],-1)),i[52]||(i[52]=l("h3",{id:"更新数据库-删除缓存",tabindex:"-1"},[n("更新数据库+删除缓存 "),l("a",{class:"header-anchor",href:"#更新数据库-删除缓存","aria-label":'Permalink to "更新数据库+删除缓存"'},"​")],-1)),i[53]||(i[53]=l("ul",null,[l("li",null,[l("strong",null,"先删除缓存，在更新数据库"),n("：读策略和写策略并发时，可能会出现缓存和数据库数据不一致的情况")]),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,"延迟双删：设置一个延迟时间，再次删除缓存，保证缓存和数据库数据一致")])]),l("li",null,[l("strong",null,"先更新数据库，再删除缓存"),n("：读策略和写策略并发时，不会出现缓存和数据库数据不一致的情况，因为"),l("strong",null,"缓存的写入远远快于数据库的写入"),n("；但是会出现删除缓存失败的情况")]),l("li",null,[n("解决方案： "),l("ul",null,[l("li",null,"消息队列重试机制：消息队列来重试缓存的删除，优点是保证缓存一致性的问题，缺点会对业务代码入侵"),l("li",null,"订阅 MySQL binlog，再操作缓存：订阅 MySQL binlog + 消息队列 + 重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题，缺点就是引入的组件比较多，对团队的运维能力比较有高要求")])])],-1)),i[54]||(i[54]=l("h3",{id:"参考-2",tabindex:"-1"},[n("参考 "),l("a",{class:"header-anchor",href:"#参考-2","aria-label":'Permalink to "参考"'},"​")],-1)),i[55]||(i[55]=l("ul",null,[l("li",null,[l("a",{href:"https://www.cnblogs.com/wzh2010/p/17205453.html",target:"_blank",rel:"noreferrer"},"Redis系列21：缓存与数据库的数据一致性讨论")])],-1))]),"main-header":s(()=>[t(e.$slots,"main-header")]),"main-header-after":s(()=>[t(e.$slots,"main-header-after")]),"main-nav":s(()=>[t(e.$slots,"main-nav")]),"main-content-before":s(()=>[t(e.$slots,"main-content-before")]),"main-content":s(()=>[t(e.$slots,"main-content")]),"main-content-after":s(()=>[t(e.$slots,"main-content-after")]),"main-nav-before":s(()=>[t(e.$slots,"main-nav-before")]),"main-nav-after":s(()=>[t(e.$slots,"main-nav-after")]),comment:s(()=>[t(e.$slots,"comment")]),footer:s(()=>[t(e.$slots,"footer")]),aside:s(()=>[t(e.$slots,"aside")]),"aside-custom":s(()=>[t(e.$slots,"aside-custom")]),default:s(()=>[t(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{M as default,O as usePageData};
