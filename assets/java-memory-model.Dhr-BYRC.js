import{_ as p}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DD9lv9nR.js";import"./chunks/@vueuse/motion.BsBBmBGk.js";import{d as f,a as v,u as b}from"./chunks/vue-router.DKq5HN5U.js";import{X as M,b_ as e,be as r,_ as a,a5 as l,bB as J,b3 as k,b5 as g}from"./framework.BXq2oTmp.js";import"./app.Cz5DIfO7.js";import"./chunks/dayjs.C6BNYsUE.js";import"./chunks/vue-i18n.lfRrKsMF.js";import"./chunks/pinia.C_YCGfgp.js";import"./chunks/nprogress.DdFZ7jLs.js";import"./YunComment.vue_vue_type_style_index_0_lang.Dyf1jjxh.js";import"./index.dXt3ZyM3.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.DDanGzXB.js";import"./post.DxTy9FEW.js";const P=f("/posts/java/java-memory-model",async t=>JSON.parse('{"title":"Java Memory Model","description":"","frontmatter":{"title":"Java Memory Model","title_zh":"Java 内存模型","date":"2024-06-21","categories":"Program","tags":["Java"]},"headers":[],"relativePath":"pages/posts/java/java-memory-model.md","lastUpdated":null}'),{lazy:(t,o)=>t.name===o.name}),U={__name:"java-memory-model",setup(t,{expose:o}){var u;const{data:s}=P(),m=b(),h=v(),i=Object.assign(h.meta.frontmatter||{},((u=s.value)==null?void 0:u.frontmatter)||{});return m.currentRoute.value.data=s.value,g("valaxy:frontmatter",i),globalThis.$frontmatter=i,o({frontmatter:{title:"Java Memory Model",title_zh:"Java 内存模型",date:"2024-06-21",categories:"Program",tags:["Java"]}}),(n,d)=>{const c=p;return k(),M(c,{frontmatter:J(i)},{"main-content-md":e(()=>d[0]||(d[0]=[a("h2",{id:"重点",tabindex:"-1"},[l("重点 "),a("a",{class:"header-anchor",href:"#重点","aria-label":'Permalink to "重点"'},"​")],-1),a("ul",null,[a("li",null,"JMM 的工作方式"),a("li",null,"三大特征：原子性、可见性、有序性"),a("li",null,"volatile 关键字"),a("li",null,"volatile 与 synchronized 的区别")],-1),a("h2",{id:"jmm-和-jvm",tabindex:"-1"},[l("JMM 和 JVM "),a("a",{class:"header-anchor",href:"#jmm-和-jvm","aria-label":'Permalink to "JMM 和 JVM"'},"​")],-1),a("p",null,"JMM 是 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本，本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。而 JVM 则是描述的是 Java 虚拟机内部及各个结构间的关系。",-1),a("ul",null,[a("li",null,"JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。"),a("li",null,"Java 内存模型（JMM） 和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。")],-1),a("h2",{id:"缓存不一致问题",tabindex:"-1"},[l("缓存不一致问题 "),a("a",{class:"header-anchor",href:"#缓存不一致问题","aria-label":'Permalink to "缓存不一致问题"'},"​")],-1),a("p",null,"解决 JMM 中的本地内存变量的缓存不一致问题有两种解决方案，分别是总线加锁和 MESI 缓存一致性协议",-1),a("h3",{id:"总线加锁",tabindex:"-1"},[l("总线加锁 "),a("a",{class:"header-anchor",href:"#总线加锁","aria-label":'Permalink to "总线加锁"'},"​")],-1),a("h3",{id:"mesi-protocol-缓存一致性协议",tabindex:"-1"},[l("MESI protocol (缓存一致性协议) "),a("a",{class:"header-anchor",href:"#mesi-protocol-缓存一致性协议","aria-label":'Permalink to "MESI protocol (缓存一致性协议)"'},"​")],-1),a("p",null,"MESI 缓存一致性协议是多个 CPU 从主内存读取同一个数据到各自的高速缓存中，当其中的某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效。",-1),a("p",null,[l("在并发编程中，如果多个线程对同一个共享变量进行操作是，我们通常会在变量名称前加上关键在"),a("strong",null,"volatile"),l(" ,因为它可以保证线程对变量的修改的可见性，保证可见性的基础是多个线程都会监听总线。即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发 read 操作读取新修改的变量的值。进而保证了多个线程的数据一致性。事实上， "),a("strong",null,"volatile"),l("的工作原理就是依赖于 MESI 缓存一致性协议实现的。")],-1),a("h2",{id:"happens-before-原则",tabindex:"-1"},[l("happens-before 原则 "),a("a",{class:"header-anchor",href:"#happens-before-原则","aria-label":'Permalink to "happens-before 原则"'},"​")],-1),a("p",null,"happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。",-1),a("h3",{id:"内存交互操作",tabindex:"-1"},[l("内存交互操作 "),a("a",{class:"header-anchor",href:"#内存交互操作","aria-label":'Permalink to "内存交互操作"'},"​")],-1),a("ul",null,[a("li",null,"lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。"),a("li",null,"read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的 load 操作使用。"),a("li",null,"load(加载)，作用于工作内存的变量，把 read 操作主存的变量放入到工作内存的变量副本中。"),a("li",null,"use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。"),a("li",null,"assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。"),a("li",null,"store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的 write 使用。"),a("li",null,"write(写入)：作用于主内存中的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。"),a("li",null,"unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")],-1),a("h3",{id:"内存交互操作规则",tabindex:"-1"},[l("内存交互操作规则 "),a("a",{class:"header-anchor",href:"#内存交互操作规则","aria-label":'Permalink to "内存交互操作规则"'},"​")],-1),a("ul",null,[a("li",null,[a("p",null,"不允许 read、load、store、write 操作之一单独出现，也就是 read 操作后必须 load，store 操作后必须 write。")]),a("li",null,[a("p",null,"不允许线程丢弃他最近的 assign 操作，即工作内存中的变量数据改变了之后，必须告知主存。")]),a("li",null,[a("p",null,"不允许线程将没有 assign 的数据从工作内存同步到主内存。")]),a("li",null,[a("p",null,"一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施 use、store 操作之前，必须经过 load 和 assign 操作。")]),a("li",null,[a("p",null,"一个变量同一时间只能有一个线程对其进行 lock 操作。多次 lock 之后，必须执行相同次数 unlock 才可以解锁。")]),a("li",null,[a("p",null,"如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值。")]),a("li",null,[a("p",null,"如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量。")]),a("li",null,[a("p",null,"一个线程对一个变量进行 unlock 操作之前，必须先把此变量同步回主内存。")]),a("li",null,[a("p",null,"Program Order Rule: Each action in a thread happens-before every action in that thread that comes later in the program order.")]),a("li",null,[a("p",null,"Monitor Lock Rule: An unlock on a monitor lock happens-before every subsequent lock on that same monitor lock.")]),a("li",null,[a("p",null,"Volatile Variable Rule: A write to a volatile field happens-before every subsequent read of that same field.")]),a("li",null,[a("p",null,"Thread Start Rule: A call to Thread.start on a thread happens-before any action in the started thread.")]),a("li",null,[a("p",null,"Thread Termination Rule: Any action in a thread happens-before any other thread detects that thread has terminated, either by successfully return from Thread.join or by Thread.isAlive returning false.")]),a("li",null,[a("p",null,"Transitivity: If A happens-before B, and B happens-before C, then A happens-before C.")])],-1),a("h2",{id:"volatile",tabindex:"-1"},[l("volatile "),a("a",{class:"header-anchor",href:"#volatile","aria-label":'Permalink to "volatile"'},"​")],-1),a("p",null,"volatile 是 Java 提供的一种轻量级的同步机制，它具有两个特性：可见性和有序性。",-1),a("h3",{id:"特性",tabindex:"-1"},[l("特性 "),a("a",{class:"header-anchor",href:"#特性","aria-label":'Permalink to "特性"'},"​")],-1),a("ul",null,[a("li",null,[l("可见性：volatile "),a("strong",null,"保证了线程间变量是可见的"),l("，即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发 read 操作读取新修改的变量的值。")]),a("li",null,[l("有序性：volatile 保证了线程对变量的修改是有序的，即"),a("strong",null,"禁止指令重排序"),l("。 "),a("ul",null,[a("li",null,"当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。"),a("li",null,"在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。")])])],-1),a("h3",{id:"应用场景",tabindex:"-1"},[l("应用场景 "),a("a",{class:"header-anchor",href:"#应用场景","aria-label":'Permalink to "应用场景"'},"​")],-1),a("ul",null,[a("li",null,[l("volatile 不能保证原子性，即"),a("strong",null,"不能保证"),l("多个线程同时修改一个变量时的"),a("strong",null,"线程安全性"),l("。")]),a("li",null,"volatile 不能代替锁，它只能保证可见性和有序性，不能保证原子性。"),a("li",null,"volatile 适用于一个线程写，多个线程读的场景。")],-1),a("h2",{id:"总结",tabindex:"-1"},[l("总结 "),a("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),a("ul",null,[a("li",null,[l("Java 是最早尝试提供内存模型的语言，其主要目的是为了"),a("strong",null,"简化多线程编程，增强程序可移植性"),l("的。")]),a("li",null,"CPU 可以通过制定缓存一致协议（比如 MESI 协议）来解决内存缓存不一致性问题。"),a("li",null,"为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致，所以在多线程下，指令重排序可能会导致一些问题。"),a("li",null,[l("你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是"),a("strong",null,"为了简化多线程编程，增强程序可移植性的"),l("。")]),a("li",null,"JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。")],-1),a("h2",{id:"参考",tabindex:"-1"},[l("参考 "),a("a",{class:"header-anchor",href:"#参考","aria-label":'Permalink to "参考"'},"​")],-1),a("ul",null,[a("li",null,[a("a",{href:"https://xie.infoq.cn/article/739920a92d0d27e2053174ef2",target:"_blank",rel:"noreferrer"},"嘿，同学，你要的 Java 内存模型 (JMM) 来了")]),a("li",null,[a("a",{href:"https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/concurrent/jmm.md",target:"_blank",rel:"noreferrer"},"JavaGuide jmm")]),a("li",null,[a("a",{href:"https://www.nowcoder.com/discuss/403852838919565312?sourceSSR=search",target:"_blank",rel:"noreferrer"},"Java 面试时常问的”JMM 高并发“你真的会回答吗？")])],-1)])),"main-header":e(()=>[r(n.$slots,"main-header")]),"main-header-after":e(()=>[r(n.$slots,"main-header-after")]),"main-nav":e(()=>[r(n.$slots,"main-nav")]),"main-content-before":e(()=>[r(n.$slots,"main-content-before")]),"main-content":e(()=>[r(n.$slots,"main-content")]),"main-content-after":e(()=>[r(n.$slots,"main-content-after")]),"main-nav-before":e(()=>[r(n.$slots,"main-nav-before")]),"main-nav-after":e(()=>[r(n.$slots,"main-nav-after")]),comment:e(()=>[r(n.$slots,"comment")]),footer:e(()=>[r(n.$slots,"footer")]),aside:e(()=>[r(n.$slots,"aside")]),"aside-custom":e(()=>[r(n.$slots,"aside-custom")]),default:e(()=>[r(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{U as default,P as usePageData};
